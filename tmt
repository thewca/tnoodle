#!/usr/bin/python

from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from os.path import exists, dirname, join, isdir, split, abspath, relpath, basename
import sys, os, imp, re, subprocess, shutil, shlex
import zipfile
import tempfile
import time

# Terribly useful debugging tweaks
import cgitb
import traceback
import pdb

cgitb.enable(display=True, format='text')
def excepthook(etype, value, tb):
	if tb:
		traceback.print_exception(etype, value, tb)
	pdb.post_mortem(tb)
sys.excepthook = excepthook

def runCmd(argv, showStatus=False, interactive=False):
    if showStatus:
            print argv
            print " ".join(argv)
    if interactive:
       p = subprocess.Popen(argv)
       p.wait()
       return p.returncode

    p = subprocess.Popen(argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout = ''
    stderr = ''
    while p.poll() is None:
            newStderr = p.stderr.read()
            if newStderr:
                    stderr += newStderr
                    if showStatus:
                            print newStderr
            newStdout = p.stdout.read()
            if newStdout:
                    stdout += newStdout
                    if showStatus:
                            print newStdout
    return p.returncode, stdout, stderr

def entryPoint():
	return split(abspath(__file__))[0]
sys.path.append(entryPoint()+'/git-tools')
if len(os.listdir('git-tools')) == 0:
        print "The git-tools directory is empty. Perhaps you haven't checked out the submodules? I'm going to try to check them out now. In the future, pass --recursive to git clone"
	runCmd([ 'git', 'submodule', 'update', '--init', '--recursive' ], showStatus=True, interactive=True)
import githubUpload
import setupGitHooks
import lint

# These are the kinds of files we replace all instances of "%%VERSION%%" with
# the current version.
TXT_FILE_EXTENSIONS = [ '.js' ]

RESOURCE_FOLDER = 'tnoodle_resources'
RESOURCE_FOLDER_SRC = 'src_%s' % RESOURCE_FOLDER
RESOURCE_FOLDER_BIN = 'bin_%s' % RESOURCE_FOLDER

def windowsOrCygwin():
	return sys.platform == 'win32' or sys.platform == 'cygwin'

if windowsOrCygwin():
	def windowsSymlink(src, linkName):
		parentDir, fileName = split(linkName)
		assert isdir(parentDir)
		src = src.replace('/', '\\')
		assert 0 == os.system("cmd /C \"cd %s && mklink /D %s %s\"" % ( parentDir, fileName, src ) )
	def islink(path):
		return readlink(path) != None
	def readlink(path):
		parentDir, fileName = split(path)
		p = subprocess.Popen([ 'dir', parentDir ], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		stdout, stderr = p.communicate()
		assert p.returncode == 0
		files = stdout.split('\n')
		symlinkRe = re.compile(r'.*SYMLINKD.*%s.*\[(.*)\].*' % fileName) # lol, this is crazy fragile
		for file in files:
			match = symlinkRe.match(file)
			if match:
				return match.group(1).replace('\\', '/')
		return None
	oldUnlink = os.unlink
	def unlink(path):
		if islink(path):
			# For some reason, Windows refuses to delete a symlink when using
			# the hacked version of islink I've create above.
			assert 0 == os.system('rmdir %s' % path)
		else:
			oldUnlink(path)

	os.unlink = unlink
	os.symlink = windowsSymlink
	os.path.islink = islink
	os.readlink = readlink

def rmtree(dir):
	# This method recursively deletes a directory, but doesn't follow any symlinks
	if not os.path.exists(dir) and not os.path.islink(dir):
		# If this path doesn't exist and is not a broken symlink,
		# then we're done!
		return
	def onerror(func, path, excinfo):
		if func == os.path.islink:
			os.unlink(path)
		else:
			raise excinfo[1]
	shutil.rmtree(dir, onerror=onerror)

def createSymlinkIfNotExistsOrStale(target, name):
	if ( not os.path.exists(name) or
		 not os.path.islink(name) or
		 not os.readlink(name) == target ):
		print "Setting up symlink %s -> %s" % ( name, target )
		rmtree(name)
		os.symlink(target, name)

PROJECT_FILE_NAME = 'tmtproject.py'
DEFAULT_PROJECT_NAME = 'all'

def dfs(node, path=()):
	assert node not in path, "Not a dag!"
	visted = [ node, ]
	path += ( node, )
	for child in node.getDependencies():
		visted += dfs(child, path)
	return visted

def rightPrune(nodes):
	prunedNodes = []
	for node in reversed(nodes):
		if node not in prunedNodes:
			prunedNodes.insert(0, node)
	return prunedNodes

def isTopologicalSort(sortedNodes):
	for i, node in enumerate(sortedNodes):
		for child in node.getDependencies():
			childIndex = sortedNodes.index(child)
			assert childIndex != i
			if childIndex < i:
				return False
	return True

def topologicalSort(rootProject):
	visitedNodes = dfs(rootProject)
	visitedNodes = rightPrune(visitedNodes)
	assert isTopologicalSort(visitedNodes)
	return visitedNodes

class tmt:
	def _cdEntryPoint(self):
		os.chdir(entryPoint())
		assert exists('README.md')

		retVal, stdout, stderr = tmt.runCmd([ 'git', 'describe' ])

		# On Lucas's computer, git describe sometimes returns a blank string. Try again a few times if this is the case.
		for i in range(8):
			if stdout != "":
				break;
			retVal, stdout, stderr = tmt.runCmd([ 'git', 'describe' ])
		
		assert retVal == 0
		self.VERSION = stdout.strip()
		versionPrefix = "v"
		assert self.VERSION.startswith(versionPrefix)
		self.VERSION = self.VERSION[len(versionPrefix):]

		retVal, stdout, stderr = self.runCmd([ "git", "ls-files", "-m", "-o", "-d", "--exclude-standard" ])
		if stdout:
			self.VERSION += "-%s" % int(time.time())

		print "Version: ", self.VERSION

		# Check that the git hooks folder is all set up
		setupGitHooks.setupGitHooksIfNotSetup()

	def _loadTmtProjects(self):
		self._cdEntryPoint()
		projectFiles = ( join(dir, PROJECT_FILE_NAME) for dir in os.listdir('.') )
		for projectFile in sorted(filter(exists, projectFiles)):
			projectName = dirname(projectFile)
			imp.load_source('', projectFile)
			assert dirname(projectFile) in tmt.TmtProject.projects

		assert DEFAULT_PROJECT_NAME in tmt.TmtProject.projects, tmt.TmtProject.projects.keys()
		defaultProject = tmt.TmtProject.projects[ DEFAULT_PROJECT_NAME ]

		for projectName, project in sorted(tmt.TmtProject.projects.iteritems()):
			project.afterProjects()

		sortedProjects = topologicalSort(defaultProject)
		for project in reversed(sortedProjects):
			project.configure()

	def _main(self):
		self._loadTmtProjects()
		self.args = tmt.parser.parse_args()
		self.args.func()

	def _graph(self):
		if tmt.args.file:
			# TODO look at tmt.args.file and generate a dotty file or something?
			assert False, "not yet implemented"
		else:
			print tmt.TmtProject.projects[tmt.args.project].prettyDependencies()

	def _getFilesList(self):
		lsFilesCmd = None
		if tmt.args.all:
			# Check every file under version control.
			lsFilesCmd = "git ls-files"
		else:
			# Check the files that git believes have been edited.
			lsFilesCmd = "git diff --cached --name-only"
		files = os.popen(lsFilesCmd).read().split('\n')
		return files

	def _lint(self):
		files = self._getFilesList()
		failures = lint.lint(files)
		if failures:
			print
			print "*********%s errors found**********" % len(failures)
			print
			sys.exit('\n'.join(failures))

	def _strings(self):
		files = self._getFilesList()
		commentOrStringRe = re.compile(r"(\"(\\.|[^\\\"])*\"|'(\\.|[^\\'])*'|//[^\n]*|/(\\.|[^\\\/\n])*/|/\*.*?\*/)", re.DOTALL)
		externalizeableFileExts = set((".js", ".java"))
		for f in files:
			if not os.path.exists(f):
				# This file must have been deleted as part of this commit.
				continue
			if os.path.isdir(f):
				continue
			fileName, ext = os.path.splitext(f)
			if ext not in externalizeableFileExts:
				continue

			contents = file(f).read()

			offsetToLineNumber = []
			lineNumber = 1
			for ch in contents:
				if ch == '\n':
					lineNumber += 1
				offsetToLineNumber.append(lineNumber)

			for match in commentOrStringRe.finditer(contents):
				start, end = match.span()
				s = match.group(0)
				if s.startswith('"') or s.startswith("'"):
					print "Found string on %s:%s  %s" % (f, offsetToLineNumber[start], s)

	def _make(self, projectName=None, command=None):
		if projectName == None:
			projectName = tmt.args.project
		if command == None:
			command = tmt.args.command
		project = tmt.TmtProject.projects[projectName]
		recurse = not tmt.args.no_recursive
		dist = False
		if recurse:
			noRecurseCommands = [ 'run', 'dist' ]
			if command in noRecurseCommands:
				print "WARNING: recurse makes no sense with the following commands: %s, so I'm ignoring it" % noRecurseCommands
				recurse = False
		if recurse:
			projects = project.getRecursiveDependenciesTopoSorted()
		else:
			projects = [ project ]

		projects.reverse()
		for project in projects:
			commandFunc = getattr(project, command, None)
			assert commandFunc, 'No %s target in %s' % ( command, project )
			commandFunc()

	def __init__(self):
		self.parser = ArgumentParser(
			description='tmt, the Tnoodle Make Tools',
			formatter_class=ArgumentDefaultsHelpFormatter)
		subparsers = self.parser.add_subparsers(help='Available commands')

		desc = 'Make stuff'
		parser_make = subparsers.add_parser(
			'make',
			help=desc, description=desc,
			formatter_class=ArgumentDefaultsHelpFormatter)
		parser_make.add_argument(
			'--project', '-p',
			default=DEFAULT_PROJECT_NAME,
			type=str,
			help='the project to build')
		parser_make.add_argument(
			'--no-recursive', '-nr',
			default=False,
			action='store_true',
			help='do not apply command recursively to dependencies')
		parser_make.add_argument(
			'command',
			nargs='?',
			choices=['compile', 'dist', 'release', 'run', 'check', 'clean'],
			default='compile',
			help='command!')
		parser_make.add_argument(
			'--args', '-a',
			default='',
			help='Command line arguments (only valid with the "run" command)')
		parser_make.add_argument(
			'--main', '-m',
			default='',
			help='Main class to run')
		parser_make.add_argument(
			'--debug', '-d',
			choices=['jdb', 'attach'],
			default=None,
			help='Run with jdb or as an attachable vm (only valid with the "run" command)')
		parser_make.add_argument(
			'--skip-noflex-warning',
			default=False,
			action='store_true',
			help="Don't bother telling me I don't have flex installed, I already know.")
		parser_make.add_argument(
			'--no-clean',
			default=False,
			action='store_true',
			help="Don't cleaning before dist-ing.")
		parser_make.set_defaults(func=self._make)

		desc = 'Generate dependency graph'
		parser_graph = subparsers.add_parser(
			'graph',
			help=desc, description=desc,
			formatter_class=ArgumentDefaultsHelpFormatter)
		parser_graph.add_argument(
			'--file', '-f',
			default='', type=str,
			help='')
		parser_graph.add_argument(
			'--project', '-p',
			default=DEFAULT_PROJECT_NAME, type=str,
			help='the project to build')
		parser_graph.add_argument(
			'--timestamps', '-t',
			action="store_true", default=False,
			help='Show project timestamps for debugging purposes')
		parser_graph.add_argument(
			'--descriptions', '-d',
			action="store_true", default=False,
			help='Show project descriptions')
		parser_graph.add_argument(
			'--no-prune', '-np',
			action="store_true", default=False,
			help='Do not prune duplicate projects')
		parser_graph.set_defaults(func=self._graph)

		desc = "Run JSLint on some (or all) js and html files. Also checks " +\
			   "for appearances of characters we don't allow in the repository"
		parser_lint = subparsers.add_parser(
			'lint',
			help=desc, description=desc,
			formatter_class=ArgumentDefaultsHelpFormatter)
		parser_lint.add_argument(
			'--all', '-a',
			action="store_true", default=False,
			help="Lint all files, even if they haven't been edited")
		parser_lint.set_defaults(func=self._lint)

		desc = "Scan files for strings ripe for i18n."
		parser_strings = subparsers.add_parser(
			'strings',
			help=desc, description=desc,
			formatter_class=ArgumentDefaultsHelpFormatter)
		parser_strings.add_argument(
			'--all', '-a',
			action="store_true", default=False,
			help="Check all files, even if they haven't been edited")
		parser_strings.set_defaults(func=self._strings)

	def memoize(self, func):
		d = {}
		evaluating = set()
		def memoed(*args):
			if not args in d:
				assert not args in evaluating, "Memoized functions may not have cycles!"
				evaluating.add(args)
				d[args] = func(*args)
				evaluating.remove(args)
			return d[args]
		return memoed

	def projectName(self):
		import traceback
		projectName, projectFileName = traceback.extract_stack()[-2][0].split(os.sep)
		assert isdir(projectName)
		assert projectFileName == PROJECT_FILE_NAME
		return projectName

	def rmtree(self, dir):
		rmtree(dir)

	def createSymlinkIfNotExistsOrStale(self, target, name):
		createSymlinkIfNotExistsOrStale(target, name)


	def runCmd(self, argv, showStatus=False, interactive=False):
        	return runCmd(argv, showStatus, interactive)

	def showCmd(self, argv):
		return self.runCmd(argv, showStatus=True)

	def timestamp(self, f):
		"""
			If f is a directory, returns the timestamp of the newest file 
			found anywhere under the given directory f.
			If f is a file, simply returns the timestamp of the given file.
			Empty/non existent directories have timestamp 0.
		"""
		if not exists(f):
			return 0

		if os.path.islink(f):
			# We don't follow symbolic links because we don't want them
			# to cause a recompile of any project that uses us.
			return os.lstat(f).st_mtime
		if not isdir(f):
			try:
				return os.lstat(f).st_mtime
			except:
				import traceback
				traceback.print_exc()
				import pdb; pdb.set_trace()

		m = 0
		for ff in os.listdir(f):
			m = max(m, self.timestamp(join(f, ff)))
		return m

	def glob(self, folder, pattern, relativeTo=None):
		matches = []
		pattern = re.compile(pattern)
		if relativeTo is None:
			relativeTo = '.'
		for root, dirs, files in os.walk(folder):
			matches += [ relpath(join(root, f), relativeTo) for f in files if pattern.match(f) ]
		return matches

	def java(self, main, classpath='', args=[], debug=None):
		command = []
		assert debug in [ None, 'jdb', 'attach' ]
		if debug == 'jdb':
			command.append('jdb')
			# TODO - passing -ea to jdb doesn't work! I HATE JAVA
		else:
			command.append('java')
			if debug == 'attach':
				command.append('-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n') # TODO - configurable port?
			command.append('-ea') # TODO - should turn on assertions at runtime
		if classpath:
			command.append('-classpath')
			command.append(classpath)
		command.append(main)
		command += args
		print " ".join(command)
		p = subprocess.Popen(command)
		return p.wait()

tmt = tmt() # We only want one instance of Tmt
sys.modules['tmt'] = tmt
# Hack for Python 2.6
import collections
from OrderedDict import OrderedDict
collections.OrderedDict = OrderedDict

class TmtProject(object):
	projects = {}
	def __init__(self, name, description):
		self.name = name
		self.description = description
		assert not name in TmtProject.projects, name
		TmtProject.projects[name] = self
	def __str__(self, timestamps=False):
		return self.name
	# The configure method of each project gets called in dependency order.
    # That is, if a project B uses a project A,
	# A.configure() will be called before B.configure().
	def configure(self):
		pass
	# The afterProjects method gets called for each project after all the projects
	# have been loaded, in no particular order.
	def afterProjects(self):
		pass
	def needsCompiling(self):
		return False
	def compile(self):
		assert False
	def dist(self):
		assert False
	def release(self):
		pass
	def run(self):
		assert False
	def clean(self):
		assert False
	def getDependencies(self):
		assert False
	def getRecursiveDependenciesTopoSorted(self):
		return topologicalSort(self)
	def prettyDependencies(self, level=0, printingLevels=None, seen=None):
		if printingLevels == None:
			assert level == 0
			printingLevels = set([0])
		else:
			printingLevels = printingLevels.copy()
		if seen == None:
			assert level == 0
			seen = set()
		indent = ''
		for i in range(level):
			if i == level-1:
				if not i in printingLevels:
					indent += '`-- '
				else:
					indent += '|-- '
			else:
				if i in printingLevels:
					indent += '|   '
				else:
					indent += '    '

		s = indent
		if self.needsCompiling():
			s += '* '
		s += self.__str__(timestamps=tmt.args.timestamps)
		if not tmt.args.no_prune and self in seen:
			# If we're pruning, and we've seen this node before,
			# then we don't recurse
			s += ' (seen)\n'
		else:
			if tmt.args.descriptions and self.description:
				s += ' - ' + self.description
			s += '\n'
			printingLevels.add(level)
			dependencies = self.getDependencies()
			for p in dependencies:
				if p == dependencies[-1]:
					printingLevels.remove(level)
				s += p.prettyDependencies(level+1, printingLevels, seen)
				seen.add(p)
		return s
tmt.TmtProject = TmtProject

@tmt.memoize
def createJarDependency(jarFile):
	return JarDependency(jarFile)

class JarDependency(TmtProject):
	def __init__(self, jarFile):
		self.jarFile = jarFile
		TmtProject.__init__(self,
				basename(jarFile),
				description="")
	def check(self):
		return
	def getDependencies(self):
		return []
	def compile(self):
		pass
	def clean(self):
		pass
	def __str__(self, timestamps=False):
		s = self.name
		if timestamps:
			s += ' %s' % tmt.timestamp(self.jarFile)
		return s

class EclipseProject(TmtProject):
	from xml.sax import make_parser, saxutils

	class EclipseClasspathHandler(saxutils.handler.ContentHandler):
		def startDocument(self):
			self.jarFiles = []
			self.projects = []

		def startElement(self, name, attrs):
			if name == 'classpathentry':
				kind = attrs.get('kind')
				path = attrs.get('path')
				if kind == 'output':
					assert path == 'bin'
				elif kind == 'src':
					if path.startswith('/'):
						self.projects.append(path[1:])
					else:
						assert path == 'src' or path == RESOURCE_FOLDER_SRC
				elif kind == 'lib':
					assert path.startswith('/')
					self.jarFiles.append(abspath(path[1:]))
				elif kind == 'con':
					pass
				else:
					assert False, 'Unrecognized kind: %s' % kind
	classpathParser = make_parser()
	classpathHandler = EclipseClasspathHandler()
	classpathParser.setContentHandler(classpathHandler)

	def __init__(self, name, description, main=None, argv=None, tests=None):
		self.main = main
		self.argv = argv
		self.nonJavaSrcDeps = []
		self.tests = tests
		TmtProject.__init__(self, name, description)

	def getDependencies(self):
		return self.jars + self.projects

	def getClasspathEntities(self, includeResources=True):
		classpath = set()
		classpath |= set(relpath(jar.jarFile) for jar in self.jars)
		classpath.add(self.bin)
		if includeResources:
			classpath.add(self.binResource)

		# The src folder only needs to be in the classpath so
		# jdb can discover the source code, and so compilation of stuff in
		# src_tnoodle_resources/ can find things defined in src/
		classpath.add(self.src)

		# TODO - I hate the world
		# Uncomment & replace the following with the path to your jre
		# if you're trying to use jbd inside of a java library method.
		#classpath.add('/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0.x86_64/src')

		for project in self.projects:
			classpath |= project.getClasspathEntities(includeResources=includeResources)
		return classpath

	def toClasspath(self, entities):
		separator = None
		if windowsOrCygwin():
			separator = ';'
		else:
			separator = ':'
		return separator.join(entities)

	def afterProjects(self):
		dependencyFile = join(self.name, '.classpath')
		assert exists(dependencyFile), dependencyFile
		EclipseProject.classpathParser.parse(dependencyFile)
		self.jars = [ createJarDependency(jar) for jar in EclipseProject.classpathHandler.jarFiles ]
		self.projects = [ tmt.TmtProject.projects[p] for p in EclipseProject.classpathHandler.projects ]
		self.bin = join(self.name, 'bin')
		self.distDir = join(self.name, 'dist')
		self.src = join(self.name, 'src')
		self.srcResource = join(self.name, RESOURCE_FOLDER_SRC)
		self.binResource = join(self.name, RESOURCE_FOLDER_BIN)
		self.fullName = 'TNoodle%s' % ( self.name[0].upper() + self.name[1:] )

		if not isdir(self.bin):
			os.mkdir(self.bin)
		if not isdir(self.binResource):
			os.mkdir(self.binResource)

	def distJarFile(self, includeVersion=True):
		# This is a function rather than a static attribute because
		# tmt.VERSION can change (see release target).
		if includeVersion:
			fileName = '%s-%s.jar' % ( self.fullName, tmt.VERSION )
		else:
			fileName = '%s.jar' % self.fullName
		return join(self.distDir, fileName)

	def needsCompiling(self):
		# Note that we assume that if the resources of a project we depend on change,
		# we don't need to recompile. This is the way resources should behave.

		if any( dep.needsCompiling() for dep in self.getDependencies() ):
			return True
		lastCompiled = tmt.timestamp(self.bin)
		depsLastTouched = ( ( tmt.timestamp(dep), dep ) for dep in self.getClasspathEntities(includeResources=False) )
		changedDeps = filter( lambda ( ts, dep ): ts > lastCompiled, depsLastTouched )
		srcLastTouched = max(tmt.timestamp(self.src), tmt.timestamp(self.srcResource))
		return lastCompiled <= srcLastTouched or len(changedDeps) > 0

	def compile(self):
		if not self.needsCompiling():
			print "%s is up to date, not recompiling" % self.name
			return False

		self._compile(self.src, self.bin)
		self._compile(self.srcResource, self.binResource)

		for nonJavaSrcDep in self.nonJavaSrcDeps:
			srcPath = join(self.srcResource, nonJavaSrcDep)
			binPath = join(self.binResource, nonJavaSrcDep)
			print "Copying %s -> %s" % ( srcPath, binPath )
			if isdir(srcPath):
				# If this dependency is a directory, we symlink to it
				# this way, we can get some changes without recompiling.
				parentDir = dirname(dirname(binPath))
				if not isdir(parentDir):
					os.makedirs(parentDir)
				if binPath.endswith('/'):
					binPath = binPath[:-1]
				srcPath = abspath(srcPath)
				srcPath = relpath(srcPath, parentDir)
				os.symlink(srcPath, binPath)
			else:
				assert not isdir(binPath)
				parentDir = dirname(binPath)
				if not isdir(parentDir):
					os.makedirs(parentDir)
				shutil.copy(srcPath, binPath)

		createSymlinkIfNotExistsOrStale(os.path.relpath(self.binResource, self.bin), join(self.bin, RESOURCE_FOLDER))

		return True

	def innerCompile(self, src, tempBin, bin):
		# omg shoot me now
		pass

	def _compile(self, src, bin):
		head, tail = os.path.split(bin)
		tempBin = join(head, "." + tail)

		print 'Compiling: %s' % src

		rmtree(bin)
		if isdir(tempBin):
			rmtree(tempBin)
		os.mkdir(tempBin)

		javaFiles = tmt.glob(src, r'.*\.java$')
		if len(javaFiles) > 0:
			args = [ 'javac' ]
			args += [ '-d', tempBin ]

            # Enable all warnings
			args += [ '-Xlint' ]
            # Treat warnings as errors
			args += [ '-Werror' ]

            # Ignored warnings
            # We don't need to be warned about possible fallthroughs in switch statements
			args += [ '-Xlint:-fallthrough' ]
            # Yes, I know I'm using the reflecation api, and no, there isn't another choice
			args += [ '-XDignore.symbol.file' ]

			entities = self.getClasspathEntities()

			# At the time we're compiling, bin/ and bin_tnoodle_resource/ don't
			# actually exist. This is becuse we compile to temp directory, and
			# move the folders only if we're successful.
			entities.remove(self.bin)
			entities.remove(self.binResource)

			classpath = self.toClasspath(entities)
			if classpath:
				args += [ '-classpath', classpath ]
			args += javaFiles
			p = subprocess.Popen(args)
			print " ".join(args)
			assert p.wait() == 0, 'javac failed!'

		self.innerCompile(src, tempBin, bin)

		print 'Compiled successfully! Renaming %s -> %s' % ( tempBin, bin )
		os.rename(tempBin, bin)

	def release(self):
		# TODO - this method is getting called for every project in the dependency heirarchy
		if tmt.args.project == self.name:
			retVal, stdout, stderr = tmt.runCmd(['git', 'ls-files', '--other', '--exclude-standard'])
			assert retVal == 0
			if stdout != '':
				print "Untracked files found, please deal with them before releasing:"
				print stdout
				return

			retVal, stdout, stderr = tmt.runCmd(['git', 'diff', '--name-only'])
			assert retVal == 0
			if stdout != '':
				print "Edited files found, please commit them before releasing:"
				print stdout
				return

			# We do a compile here even though we're going to do dist later
			# in order to catch compile errors before we make a tag.
			tmt._make(projectName=self.name, command='compile')

			print "Releasing", self.name

			assert exists('VERSION')
			versionFileContents = file('VERSION').read().split('\n')
			tmt.VERSION = None
			for line in versionFileContents:
				if not line.startswith("#"):
					tmt.VERSION = line
					break
			assert tmt.VERSION
			tag = "v%s" % tmt.VERSION
			tagMessage = "version %s" % tmt.VERSION
			tagCommand = "git tag -a %s -m '%s'" % (tag, tagMessage)
			print tagCommand
			assert 0 == os.system(tagCommand)
			print "Successfully created tag %s" % tag

			# We can't run a dist until after we create the tag. This way
			# the version number of the resulting file will be correct.
			self.dist()

			githubUpload.githubConnect(organization="cubing", repo="tnoodle")
			if not githubUpload.githubUpload(self.distJarFile()):
				print "Failed to upload %s, see above for details" % self.distJarFile()
				print "Deleting tag %s" % tag
				return

			pushTagsCommand = 'git push --tags'
			print pushTagsCommand
			assert 0 == os.system(pushTagsCommand)

	def dist(self):
		if not tmt.args.no_clean:
			# We explicitly clean here, because stuff may have ended up in our
			# resources folders that we don't want to include in the generated jar file.
			tmt._make(projectName=self.name, command='clean')

		if not isdir(self.distDir):
			os.mkdir(self.distDir)

		tmt._make(projectName=self.name, command='compile')
		jar = zipfile.ZipFile(self.distJarFile(), "w", compression=zipfile.ZIP_DEFLATED)

		jarDeps = []
		javaDeps = []
		for project in self.getRecursiveDependenciesTopoSorted():
			if hasattr(project, 'jarFile'):
				jarDeps.append(project)
			else:
				if isinstance(project, tmt.EclipseProject):
					# If we depend on a project that isn't an eclipse project,
					# we're probably symlinking into that project, so there's
					# no need to slurp in any of its resources manually.
					# One example of where we do this is for js projects.
					# In fact, we don't even need these projects to show up in the
					# dependency graph, but it's nice to keep "tmt graph" up to date.
					# TODO - symlinking into other projects isn't a great idea,
					# what if a -> c, a -> b, and b -> c ?
					javaDeps.append(project)

		# We don't want to include dotfiles in our jar file. This solves the problem of
		# accidentally including submodules's .git folder.
		notDotfile = lambda dirname: not dirname.startswith(".")

		if jarDeps:
			extractedLibDir = tempfile.mkdtemp()
			for jarDep in jarDeps:
				jarLib = zipfile.ZipFile(jarDep.jarFile)
				jarLib.extractall(path=extractedLibDir)
			for dirpath, dirnames, filenames in os.walk(extractedLibDir):
				dirnames[:] = filter(notDotfile, dirnames) # Note that we're modifying dirnames in place

				for name in filenames:
					if not notDotfile(name):
						continue
					if dirpath.lower().endswith("meta-inf") and name.lower().endswith(".sf"):
						# We don't want to include signatures in our monolithic jar file, see
						# http://stackoverflow.com/questions/999489/invalid-signature-file-when-attempting-to-run-a-jar
						continue
					path = os.path.normpath(os.path.join(dirpath, name))
					arcPath = os.path.relpath(path, extractedLibDir)
					if os.path.isfile(path):
						jar.write(path, arcPath)
			rmtree(extractedLibDir)

		for project in javaDeps:
			for dirpath, dirnames, filenames in os.walk(project.bin, followlinks=True):
				dirnames[:] = filter(notDotfile, dirnames) # Note that we're modifying dirnames in place

				for name in filenames:
					if not notDotfile(name):
						continue
					path = os.path.normpath(os.path.join(dirpath, name))
					arcPath = os.path.relpath(path, project.bin)
					if os.path.isfile(path):
						if os.path.splitext(path)[1] in TXT_FILE_EXTENSIONS:
							txt = file(path).read()
							# This might be a pretty heavy hammer, but who in the world
							# would legitimately want to use the string "%%VERSION%%"?
							# Famous last words?
							txt = txt.replace("%%VERSION%%", tmt.VERSION)
							jar.writestr(arcPath, txt)
						else:
							jar.write(path, arcPath)

		manifest = """\
Manifest-Version: 1.0
Main-Class: %s
Implementation-Title: %s
Implementation-Version: %s
""" % ( self.main, self.fullName, tmt.VERSION )
		jar.writestr('META-INF/MANIFEST.MF', manifest)

		jar.close()

		noVersionPath = self.distJarFile(includeVersion=False)

		createSymlinkIfNotExistsOrStale(basename(self.distJarFile()), noVersionPath)

		print 'Successfully created %s with main class %s' % ( self.distJarFile(), self.main )

	def run(self):
		main = tmt.args.main or self.main
		assert main, 'Main class not defined'
		assert tmt.args.args is not None # shlex reads from stdin if you pass None, lol
		tmt._make(projectName=self.name, command='compile')
		# TODO propogate return code up
		args = shlex.split(tmt.args.args)
		if self.argv:
			args += self.argv
		tmt.java(
			main=main,
			classpath=self.toClasspath(self.getClasspathEntities(includeResources=False)),
			args=args,
			debug=tmt.args.debug)

	def check(self):
		if not self.tests:
			return

		tmt._make(projectName=self.name, command='compile')

		for testClass in self.tests:
			assert 0 == tmt.java(main=testClass,
                                 classpath=self.toClasspath(self.getClasspathEntities()))

	def clean(self):
		print 'Cleaning: %s' % self.name
		if exists(self.bin):
			assert isdir(self.bin)
			rmtree(self.bin)
		if exists(self.binResource):
			assert isdir(self.binResource)
			rmtree(self.binResource)
		if exists(self.distDir):
			assert isdir(self.distDir)
			rmtree(self.distDir)
		tempBin = join(self.name, '.bin')
		if isdir(tempBin):
			rmtree(tempBin)

	def __str__(self, timestamps=False):
		s = self.name
		if timestamps:
			binTs = tmt.timestamp(self.bin)
			srcTs = tmt.timestamp(self.src)
			srcResourceTs = tmt.timestamp(self.srcResource)
			s += ' bin: %s src: %s src_resource: %s' % ( binTs, srcTs, srcResourceTs )
		return s

tmt.EclipseProject = EclipseProject

if __name__ == "__main__":
	tmt._main()
